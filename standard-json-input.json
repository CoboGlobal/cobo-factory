{"language":"Solidity","sources":{"src/CoboFactory.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.20;\n\n/**\n * @title Cobo Factory Smart Contract\n * @author https://github.com/coboglobal\n * @dev Inspired by https://github.com/pcaversaccio/createx\n */\ncontract CoboFactory {\n    \n    event ContractDeployed(\n        address indexed _contract,\n        address indexed _deployer\n    );\n\n    uint256 constant CREATE3_BIT = 0x1; \n    uint256 constant WITH_SENDER_BIT = 0x2;\n    uint256 constant EMIT_EVENT_BIT = 0x4;\n\n    uint256 constant CREATE2_TAG = 2;\n    uint256 constant CREATE3_TAG = 3;\n\n    enum DeployType {\n        Create2,                  // None = 0\n        Create3,                  // CREATE3_BIT = 1\n        Create2WithSender,        // WITH_SENDER_BIT = 2\n        Create3WithSender,        // CREATE3_BIT | WITH_SENDER_BIT = 3\n        Create2AndEmit,           // EMIT_EVENT_BIT = 4\n        Create3AndEmit,           // CREATE3_BIT | EMIT_EVENT_BIT = 5\n        Create2WithSenderAndEmit, // WITH_SENDER_BIT | EMIT_EVENT_BIT = 6\n        Create3WithSenderAndEmit  // CREATE3_BIT | WITH_SENDER_BIT | EMIT_EVENT_BIT = 7\n    }\n\n    function _guardSalt(\n        address sender,\n        bytes32 salt,\n        uint256 tag\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(sender, salt, tag));\n    }\n\n    function deployCreate2(\n        bytes32 salt,\n        bytes memory initCode,\n        bool _private,\n        bool _emit\n    ) public returns (address _contract) {\n        address sender = _private ? msg.sender : address(0);\n        salt = _guardSalt(sender, salt, CREATE2_TAG);\n        assembly {\n            _contract := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        require(_contract != address(0), \"Create2 failed\");\n        if (_emit){\n            emit ContractDeployed(_contract, msg.sender);\n        }\n    }\n\n    function deployCreate3(\n        bytes32 salt,\n        bytes memory initCode,\n        bool _private,\n        bool _emit\n    ) public returns (address _contract) {\n        address sender = _private ? msg.sender : address(0);\n        bytes32 finalSalt = _guardSalt(sender, salt, CREATE3_TAG);\n        bytes\n            memory proxyChildBytecode = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n        address proxy;\n        assembly {\n            proxy := create2(\n                0,\n                add(proxyChildBytecode, 32),\n                mload(proxyChildBytecode),\n                finalSalt\n            )\n        }\n        require(proxy != address(0), \"Create3 proxy failed\");\n\n        (bool success, bytes memory _retData) = proxy.call(initCode);\n        if (!success) {\n            assembly {\n                let size := mload(_retData)\n                revert(add(32, _retData), size)\n            }\n        }\n        _contract = getCreate3Address(salt, sender);\n        require(_contract.code.length > 0, \"Create3 failed\");\n        if (_emit){\n            emit ContractDeployed(_contract, msg.sender);\n        }\n    }\n\n    function deploy(\n        DeployType typ,\n        bytes32 salt,\n        bytes memory initCode\n    ) public returns (address _contract) {\n        uint256 typeBits = uint256(typ);\n        bool create3 = typeBits & CREATE3_BIT == CREATE3_BIT;\n        bool withSender = typeBits & WITH_SENDER_BIT == WITH_SENDER_BIT;\n        bool emitEvent = typeBits & EMIT_EVENT_BIT == EMIT_EVENT_BIT;\n\n        if(create3){\n            return deployCreate3(salt, initCode, withSender, emitEvent);\n        }else{\n            return deployCreate2(salt, initCode, withSender, emitEvent);\n        }\n    }\n\n    function deployAndInit(\n        DeployType typ,\n        bytes32 salt,\n        bytes calldata initCode,\n        bytes calldata callData\n    ) public returns (address _contract) {\n        _contract = deploy(typ, salt, initCode);\n        (bool success, bytes memory _retData) = _contract.call(callData);\n        if (!success) {\n            assembly {\n                let size := mload(_retData)\n                revert(add(32, _retData), size)\n            }\n        }\n    }\n\n    function getCreate2Address(\n        bytes32 salt,\n        address sender,\n        bytes calldata initCode\n    ) public view returns (address _contract) {\n        bytes32 initCodeHash = keccak256(initCode);\n        address deployer = address(this);\n        salt = _guardSalt(sender, salt, CREATE2_TAG);\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x40), initCodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer)\n            let start := add(ptr, 0x0b)\n            mstore8(start, 0xff)\n            _contract := keccak256(start, 85)\n        }\n    }\n\n    function getCreate3Address(\n        bytes32 salt,\n        address sender\n    ) public view returns (address _contract) {\n        address deployer = address(this);\n        salt = _guardSalt(sender, salt, CREATE3_TAG);\n        assembly {\n            let ptr := mload(0x40)\n            mstore(0x00, deployer)\n            mstore8(0x0b, 0xff)\n            mstore(0x20, salt)\n            mstore(\n                0x40,\n                hex\"21_c3_5d_be_1b_34_4a_24_88_cf_33_21_d6_ce_54_2f_8e_9f_30_55_44_ff_09_e4_99_3a_62_31_9a_49_7c_1f\"\n            )\n            mstore(0x14, keccak256(0x0b, 0x55))\n            mstore(0x40, ptr)\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01)\n            _contract := keccak256(0x1e, 0x17)\n        }\n    }\n\n    function getAddress(\n        DeployType typ,\n        bytes32 salt,\n        address sender,\n        bytes calldata initCode\n    ) external view returns (address _contract) {\n        typ = DeployType(uint256(typ) & (CREATE3_BIT | WITH_SENDER_BIT));\n        if (typ == DeployType.Create2) {\n            _contract = getCreate2Address(salt, address(0), initCode);\n        } else if (typ == DeployType.Create2WithSender) {\n            _contract = getCreate2Address(salt, sender, initCode);\n        } else if (typ == DeployType.Create3) {\n            _contract = getCreate3Address(salt, address(0));\n        } else if (typ == DeployType.Create3WithSender) {\n            _contract = getCreate3Address(salt, sender);\n        }\n    }\n}\n"}},"settings":{"remappings":["ds-test/=lib/forge-std/lib/ds-test/src/","forge-std/=lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":20000},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"london","viaIR":true,"libraries":{}}}
